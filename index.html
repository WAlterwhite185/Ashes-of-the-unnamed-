<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ashes of the Unnamed — Retro 3D Gothic Action (Web)</title>
  <style>
    :root {
      --ui-bg: rgba(6,6,8,0.7);
      --ui-fg: #e5e5e5;
      --ui-accent: #b51f2a;
      --gold: #c7a65a;
      --hp: #b51f2a;       /* Eldritch red */
      --st: #6ea0c9;       /* Cold blue */
      --mp: #7abf6e;       /* Sickly green (colorblind-safe with others) */
    }
    html, body {
      margin: 0;
      height: 100%;
      background: #0a0a0a;
      color: var(--ui-fg);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif;
      overflow: hidden;
    }
    #root {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 800px at 50% 50%, #171717 0%, #0a0a0a 60%);
    }
    /* 16:9 responsive letterbox */
    #stage {
      position: relative;
      width: 100vw;
      height: 56.25vw;        /* 16:9 */
      max-height: 100vh;
      max-width: 177.78vh;
      background: #000;
      overflow: hidden;
      box-shadow: 0 0 60px rgba(0,0,0,0.7) inset;
      border: 1px solid #222;
    }
    canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
    /* Top HUD */
    #hud {
      position: absolute; inset: 0; pointer-events: none;
      font-weight: 600;
      text-shadow: 0 2px 0 #000, 0 0 8px rgba(0,0,0,0.6);
    }
    .bars {
      position: absolute; left: 12px; top: 12px; right: 12px;
      display: grid; grid-template-columns: 1fr; gap: 6px;
    }
    .bar {
      background: rgba(20,20,24,0.8); border: 1px solid #2a2a2a; height: 12px;
      box-shadow: 0 0 12px rgba(0,0,0,0.4) inset, 0 0 30px rgba(0,0,0,0.2);
      position: relative; overflow: hidden;
    }
    .bar span {
      position: absolute; left: 0; top: 0; bottom: 0; width: 70%;
      display: block;
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(0,0,0,0.12)),
                  repeating-linear-gradient(90deg, rgba(255,255,255,0.05) 0 6px, transparent 6px 12px);
      transition: width .15s ease-out;
    }
    .bar.hp span { background-color: var(--hp); mix-blend-mode: screen; }
    .bar.st span { background-color: var(--st); mix-blend-mode: screen; }
    .bar.mp span { background-color: var(--mp); mix-blend-mode: screen; }
    /* Grain overlay */
    #grain {
      position: absolute; inset: -10%; pointer-events: none;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="140" height="140"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23n)"/></svg>');
      opacity: .05; mix-blend-mode: screen; animation: grain 1s steps(2) infinite;
      transform: translateZ(0);
    }
    @keyframes grain { 0%{transform:translate(0,0)} 25%{transform:translate(-2%,1%)} 50%{transform:translate(1%,-1%)} 75%{transform:translate(2%,1%)} 100%{transform:translate(0,0)} }
    /* Title/Start overlay */
    #title {
      position: absolute; inset: 0;
      background: radial-gradient(1200px 800px at 50% 50%, rgba(0,0,0,0.55), rgba(0,0,0,0.9));
      display: grid; place-items: center; gap: 12px;
    }
    .panel {
      background: var(--ui-bg); border: 1px solid #2e2e2e; padding: 16px 18px; max-width: 720px;
      box-shadow: 0 12px 60px rgba(0,0,0,0.5);
    }
    h1 {
      margin: 0 0 8px; font-size: 24px; letter-spacing: 1px; text-transform: uppercase;
    }
    .btn {
      pointer-events: auto;
      display: inline-block; background: linear-gradient(180deg, #2b1013, #110708);
      color: #f5e3e3; border: 1px solid #4a1a20; padding: 10px 14px;
      text-transform: uppercase; letter-spacing: 1px; cursor: pointer;
      box-shadow: 0 6px 20px rgba(181,31,42,0.25);
    }
    .btn:hover { filter: brightness(1.15); }
    #tips { font-size: 12px; opacity: 0.9; }
    /* Pause/Options */
    #pause {
      position: absolute; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.55);
    }
    #pause .panel { width: 560px; }
    label { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 8px 0; }
    input[type="range"]{ width: 220px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    #credits, #ending { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; background: #000; color: #eaeaea; }
    #credits .panel, #ending .panel { text-align: center; }
    #fs { position: absolute; right: 8px; bottom: 8px; pointer-events: auto; }
    /* Subtitles */
    #subs {
      position: absolute; left: 0; right: 0; bottom: 12px; display: grid; place-items: center;
      pointer-events: none; font-size: 14px;
    }
    #subs .line { background: rgba(0,0,0,0.55); padding: 6px 8px; border: 1px solid #333; max-width: 70%; text-align: center; }
    /* On-screen small status (lore pickups) */
    #toast { position: absolute; left: 50%; transform: translateX(-50%); top: 18px; background: rgba(0,0,0,0.55); padding: 6px 8px; border: 1px solid #333; display: none; }
  </style>
</head>
<body>
  <div id="root">
    <div id="stage">
      <canvas id="game"></canvas>
      <div id="hud" aria-hidden="true">
        <div class="bars">
          <div class="bar hp" aria-label="Health"><span id="hpFill" style="width:100%"></span></div>
          <div class="bar st" aria-label="Stamina"><span id="stFill" style="width:100%"></span></div>
          <div class="bar mp" aria-label="Mana"><span id="mpFill" style="width:100%"></span></div>
        </div>
        <div id="grain"></div>
        <div id="subs"><div class="line" id="subsLine" style="display:none"></div></div>
        <div id="toast"></div>
      </div>
      <div id="title">
        <div class="panel">
          <h1>ASHES OF THE UNNAMED</h1>
          <p style="opacity:.9;margin:8px 0 12px">A fast, retro-3D gothic action micro‑slice (Doom/Quake vibes × Bloodborne gloom). Click to start; then click the game to capture mouse. Works in Google Sites iframes.</p>
          <div class="row">
            <button id="startBtn" class="btn">Click to Start</button>
            <button id="howBtn" class="btn" style="background:#141414;border-color:#333;box-shadow:none">Controls</button>
          </div>
          <div id="tips" style="margin-top:12px">
            <div><strong>WASD</strong> move • <strong>Mouse</strong> look • <strong>Shift</strong> sprint • <strong>Space</strong> jump/dodge • <strong>LMB</strong> light/heavy (hold) • <strong>RMB</strong> block/parry • <strong>Q</strong> Grave Lance • <strong>E</strong> Eldritch Bolt • <strong>R</strong> Tincture • <strong>Tab</strong> wheel (slow‑mo) • <strong>Esc</strong> pause/options</div>
          </div>
        </div>
      </div>
      <div id="pause">
        <div class="panel">
          <h2 style="margin:0 0 8px">Options</h2>
          <label>Master Volume <input id="vol" type="range" min="0" max="1" step="0.01" value="0.8"/></label>
          <label>FOV <input id="fov" type="range" min="75" max="110" step="1" value="100"/></label>
          <label>Mouse Sensitivity <input id="sens" type="range" min="0.2" max="2.0" step="0.05" value="1.0"/></label>
          <label>Screen Shake <input id="shake" type="range" min="0" max="1" step="0.01" value="0.35"/></label>
          <label>Chromatic Aberration <input id="aberr" type="range" min="0" max="1" step="0.01" value="0.15"/></label>
          <div class="row" style="justify-content:space-between;margin-top:8px">
            <div class="row">
              <button id="resumeBtn" class="btn">Resume</button>
              <button id="resetRunBtn" class="btn" title="Clears local save">Reset Run</button>
            </div>
            <button id="toTitleBtn" class="btn" style="background:#111;border-color:#333;box-shadow:none">Quit to Title</button>
          </div>
        </div>
      </div>
      <div id="credits">
        <div class="panel">
          <h2>Credits</h2>
          <p>Design & Code: Placeholder • Music/SFX: Procedural WebAudio • Engine: Three.js</p>
          <p>Press any key to return to title.</p>
        </div>
      </div>
      <div id="ending">
        <div class="panel">
          <h2>The Cold Cathedral</h2>
          <p>You awaken in silence. The nave is empty. Your hands are slick, cradling a crown and the king's body.</p>
          <p><em>The Unnamed</em> murmurs—letters unmake and flicker. Then nothing.</p>
          <p>Press any key to roll credits.</p>
        </div>
      </div>
      <button id="fs" class="btn" title="Toggle Fullscreen">Fullscreen</button>
    </div>
  </div>

  <!-- Using ES modules from a stable CDN for the prototype. To vendor locally, download these files and reference with relative paths. -->
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
    import { PointerLockControls } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/controls/PointerLockControls.js";

    // ---------- Globals & State ----------
    const canvas = document.getElementById("game");
    const stage = document.getElementById("stage");
    const title = document.getElementById("title");
    const pause = document.getElementById("pause");
    const credits = document.getElementById("credits");
    const ending = document.getElementById("ending");
    const hud = {
      hp: document.getElementById("hpFill"),
      st: document.getElementById("stFill"),
      mp: document.getElementById("mpFill"),
      toast: document.getElementById("toast"),
      subs: document.getElementById("subsLine"),
    };
    const btn = {
      start: document.getElementById("startBtn"),
      how: document.getElementById("howBtn"),
      fs: document.getElementById("fs"),
      resume: document.getElementById("resumeBtn"),
      reset: document.getElementById("resetRunBtn"),
      toTitle: document.getElementById("toTitleBtn"),
    };
    const opt = {
      vol: document.getElementById("vol"),
      fov: document.getElementById("fov"),
      sens: document.getElementById("sens"),
      shake: document.getElementById("shake"),
      aberr: document.getElementById("aberr"),
    };

    let WIDTH = stage.clientWidth, HEIGHT = stage.clientHeight;
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: false, alpha: false, powerPreference: 'high-performance' });
    renderer.setSize(WIDTH, HEIGHT, false);
    renderer.setPixelRatio(1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.BasicShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);
    scene.fog = new THREE.FogExp2(0x0b0b10, 0.04);

    const camera = new THREE.PerspectiveCamera(parseFloat(opt.fov.value), WIDTH/HEIGHT, 0.1, 200);
    camera.position.set(0, 1.6, 6);

    const controls = new PointerLockControls(camera, stage);
    let pointerLocked = false;
    stage.addEventListener('click', () => {
      if (!pointerLocked) {
        controls.lock();
      }
    });
    controls.addEventListener('lock', () => { pointerLocked = true; });
    controls.addEventListener('unlock', () => { pointerLocked = false; });

    // Pixelated sampler helper
    function pixelateTexture(tex){
      tex.minFilter = THREE.NearestFilter;
      tex.magFilter = THREE.NearestFilter;
      tex.generateMipmaps = false;
      tex.needsUpdate = true;
      return tex;
    }

    // ---------- Procedural textures (canvas) ----------
    function makeTexture(w, h, paintFn){
      const c = document.createElement('canvas'); c.width=w; c.height=h;
      const g = c.getContext('2d');
      paintFn(g, w, h);
      const tex = new THREE.CanvasTexture(c);
      return pixelateTexture(tex);
    }
    const texBrick = makeTexture(256,256,(g,w,h)=>{
      g.fillStyle='#2a2426'; g.fillRect(0,0,w,h);
      for(let y=0;y<h;y+=24){
        for(let x=((y/24)%2)*18;x<w;x+=36){
          g.fillStyle = '#3a3234';
          g.fillRect(x+1,y+1,34,22);
          g.fillStyle = '#473e40'; g.fillRect(x+2,y+2,32,20);
          g.fillStyle = 'rgba(0,0,0,0.25)'; g.fillRect(x+2,y+20,32,2);
        }
      }
      // soot specks
      for(let i=0;i<800;i++){
        const x = Math.random()*w, y = Math.random()*h;
        g.fillStyle = `rgba(0,0,0,${Math.random()*0.25})`;
        g.fillRect(x,y,1,1);
      }
    });
    const texWood = makeTexture(256,256,(g,w,h)=>{
      g.fillStyle='#2a221a'; g.fillRect(0,0,w,h);
      for(let i=0;i<14;i++){
        const y=i*(h/14);
        g.fillStyle='#3b2f22'; g.fillRect(0,y+1,w,(h/14)-2);
        g.fillStyle='rgba(0,0,0,0.2)'; g.fillRect(0,y+(h/14)-3,w,2);
      }
      // grain
      g.strokeStyle='rgba(255,255,255,0.05)';
      for(let i=0;i<50;i++){
        g.beginPath(); g.moveTo(0, Math.random()*h);
        g.bezierCurveTo(w*0.3, Math.random()*h, w*0.6, Math.random()*h, w, Math.random()*h);
        g.stroke();
      }
    });
    const texStone = makeTexture(256,256,(g,w,h)=>{
      g.fillStyle='#191a1d'; g.fillRect(0,0,w,h);
      for(let i=0;i<260;i++){
        const x=Math.random()*w, y=Math.random()*h, r=2+Math.random()*4;
        g.fillStyle=`rgba(255,255,255,${Math.random()*0.08})`;
        g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
      }
    });
    const texFlesh = makeTexture(256,256,(g,w,h)=>{
      const grd = g.createLinearGradient(0,0,w,h);
      grd.addColorStop(0,'#5a2424'); grd.addColorStop(1,'#2b0f0f');
      g.fillStyle=grd; g.fillRect(0,0,w,h);
      for(let i=0;i<180;i++){
        g.fillStyle=`rgba(255,120,120,${Math.random()*0.15})`;
        g.beginPath(); g.ellipse(Math.random()*w,Math.random()*h,6+Math.random()*16,2+Math.random()*6,Math.random()*3.14,0,6.28); g.fill();
      }
    });
    const matBrick = new THREE.MeshLambertMaterial({ map: texBrick });
    const matWood  = new THREE.MeshLambertMaterial({ map: texWood });
    const matStone = new THREE.MeshLambertMaterial({ map: texStone });
    const matFlesh = new THREE.MeshLambertMaterial({ map: texFlesh, emissive:new THREE.Color(0x220000), emissiveIntensity:0.15 });

    // ---------- Lights ----------
    const amb = new THREE.AmbientLight(0x222222, 1.3); scene.add(amb);
    const fireLight = new THREE.PointLight(0xff4a22, 2, 18); fireLight.position.set(0, 3, 0); scene.add(fireLight);

    // Flicker
    function updateFireLight(t){
      fireLight.intensity = 1.6 + Math.sin(t*9.3)*0.2 + Math.sin(t*14.7)*0.15;
    }

    // ---------- World ----------
    const world = new THREE.Group(); scene.add(world);

    // Floor
    const floorGeo = new THREE.PlaneGeometry(200,200, 4,4);
    const floor = new THREE.Mesh(floorGeo, matStone); floor.rotation.x = -Math.PI/2; floor.receiveShadow=true; world.add(floor);

    // Simple town blocks
    function addBlock(x,z,w,d,h,mat){
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
      mesh.position.set(x, h/2, z); mesh.castShadow = true; mesh.receiveShadow=true; world.add(mesh);
      return mesh;
    }

    // Layout zones (very lightweight mock of the spec)
    const zones = [];
    function buildTown(){
      // Outskirts
      for(let i=0;i<10;i++){
        addBlock(-20 + i*4, -10, 3,3, 4+Math.random()*2, matBrick);
      }
      // Market streets
      for(let i=0;i<12;i++){
        addBlock(-10 + i*3, -2, 2.5,2.5, 6+Math.random()*3, matBrick);
        if(i%3===0) addBlock(-10 + i*3, 4, 2,2, 6, matWood);
      }
      // Bell tower stub
      const tower = addBlock(18, -4, 4,4, 14, matBrick);
      // Cathedral front
      const catFrontL = addBlock(32,  -6, 5,5, 10, matStone);
      const catFrontR = addBlock(32,   6, 5,5, 10, matStone);
      // Cathedral nave walls
      for(let i=0;i<6;i++){
        addBlock(38+i*4, -6, 3,3, 8, matStone);
        addBlock(38+i*4,  6, 3,3, 8, matStone);
      }
      // Boss arena center pad
      const pad = new THREE.Mesh(new THREE.CylinderGeometry(4,4,0.7, 16), matStone);
      pad.position.set(52, 0.35, 0); pad.receiveShadow=true; world.add(pad);
    }
    buildTown();

    // ---------- Shrines (checkpoints) ----------
    const shrines = [];
    function makeShrine(x,z){
      const s = new THREE.Mesh(new THREE.CylinderGeometry(0.8,1.2,1.2, 12), new THREE.MeshLambertMaterial({color:0x444466}));
      s.position.set(x, 0.6, z); s.castShadow=true; world.add(s);
      shrines.push(s);
      return s;
    }
    makeShrine(-12, -6);
    makeShrine(8, -2);
    makeShrine(36, 2);

    // ---------- Player ----------
    const player = {
      pos: new THREE.Vector3( -18, 1.6, -10 ),
      vel: new THREE.Vector3(),
      onGround: false,
      yaw: 0,
      hp: 100, st: 100, mp: 60,
      maxHp: 100, maxSt: 100, maxMp: 60,
      staminaDrain: 0,
      parryWindow: 0,  // seconds remaining
      iFrames: 0,      // dodge invuln timer
      lastShrine: 0,
      alive: true,
    };
    camera.position.copy(player.pos);

    // ---------- Input ----------
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.code]=true;
      if (e.code==='Escape') togglePause(true);
    });
    window.addEventListener('keyup', e => { keys[e.code]=false; });

    // ---------- Audio ----------
    const audio = {
      ctx: null, master: null, vol: parseFloat(opt.vol.value),
      ready: false
    };
    function initAudio(){
      if(audio.ready) return;
      audio.ctx = new (window.AudioContext||window.webkitAudioContext)();
      const master = audio.ctx.createGain(); master.gain.value = audio.vol; master.connect(audio.ctx.destination); audio.master = master;
      audio.ready = true;
    }
    opt.vol.addEventListener('input', ()=>{
      audio.vol = parseFloat(opt.vol.value);
      if(audio.master) audio.master.gain.value = audio.vol;
    });
    function tone({f=220, t=0.06, type='square', v=0.2}){
      if(!audio.ready) return;
      const o = audio.ctx.createOscillator();
      o.type = type; o.frequency.value = f;
      const g = audio.ctx.createGain(); g.gain.value = v;
      o.connect(g); g.connect(audio.master);
      o.start();
      g.gain.setValueAtTime(v, audio.ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.0001, audio.ctx.currentTime + t);
      o.stop(audio.ctx.currentTime + t + 0.02);
    }
    const sfx = {
      step: ()=>tone({f: 120, t:0.03, v:0.06, type:'triangle'}),
      hit: ()=>tone({f: 90, t:0.08, v:0.2, type:'square'}),
      parry: ()=>{ tone({f:640, t:0.07, v:0.2, type:'sawtooth'}); tone({f:860, t:0.07, v:0.2, type:'triangle'}); },
      cast: ()=>tone({f: 300, t:0.09, v:0.18, type:'sawtooth'}),
      riposte: ()=>tone({f: 200, t:0.14, v:0.25, type:'square'}),
      shrine: ()=>tone({f: 520, t:0.2, v:0.2, type:'triangle'}),
      bossHit: ()=>tone({f: 60, t:0.12, v:0.28, type:'square'}),
    };

    // ---------- Simple CRT/aberration post-fx (very cheap) ----------
    let aberration = parseFloat(opt.aberr.value);
    opt.aberr.addEventListener('input', ()=> aberration = parseFloat(opt.aberr.value));
    function postFx(){
      // Cheap chromatic aberration via camera jitter (very light)
      camera.projectionMatrix.elements[8] = (Math.random()*2-1) * 0.0008 * aberration;
      camera.projectionMatrix.elements[9] = (Math.random()*2-1) * 0.0008 * aberration;
    }

    // ---------- Enemies & Combat ----------
    const enemies = [];
    function makeEnemy(type, x,z){
      const h = type==='hound'? 0.9 : 1.4;
      const mat = (type==='wraith')? new THREE.MeshLambertMaterial({color:0x556677, transparent:true, opacity:0.75}) :
                 (type==='templar')? new THREE.MeshLambertMaterial({color:0x222222, emissive:0x111111}) :
                 new THREE.MeshLambertMaterial({color:0x333333});
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.8,h,0.8), mat);
      mesh.position.set(x,h/2,z); mesh.castShadow = true; world.add(mesh);
      return {
        type, mesh,
        hp: (type==='templar')? 70 : (type==='hound'? 20 : 40),
        maxHp: (type==='templar')? 70 : (type==='hound'? 20 : 40),
        speed: (type==='hound')? 6.2 : 3.2,
        cd: 0, stagger: 0, dead: false, aggro: false,
        teleportCd: 0,
        shield: (type==='templar')? 1.0 : 0.0,
      };
    }
    function spawnWave(){
      enemies.push(makeEnemy('squire', -10, -8));
      enemies.push(makeEnemy('archer', -4, -2));
      enemies.push(makeEnemy('hound',  3, -2));
      enemies.push(makeEnemy('acolyte', 8, 2));
      enemies.push(makeEnemy('templar', 14, -3));
      // Graveyard wraiths
      enemies.push(makeEnemy('wraith', 26, -2));
      enemies.push(makeEnemy('wraith', 28, 2));
    }
    spawnWave();

    // Boss
    const boss = {
      mesh: null, hp: 300, maxHp: 300, phase: 1, cd: 3, dead:false, active:false
    };
    function buildBoss(){
      const m = new THREE.Mesh(new THREE.BoxGeometry(4,6,3), matFlesh);
      m.position.set(52, 3, 0); m.castShadow=true; world.add(m);
      boss.mesh = m;
    }
    buildBoss();

    // Projectiles
    const projectiles = []; // {mesh, vel, dmg, ttl, owner:'player'|'enemy'}
    function shoot(from, dir, speed, dmg, owner='player'){
      const geo = new THREE.SphereGeometry(0.12, 8,8);
      const mat = new THREE.MeshBasicMaterial({color: owner==='player'?0x88ff88:0xff8844});
      const p = new THREE.Mesh(geo, mat); p.position.copy(from); world.add(p);
      projectiles.push({ mesh: p, vel: dir.multiplyScalar(speed), dmg, ttl: 3.5, owner });
    }

    // Melee & parry
    let attackCd = 0, blockHeld = false, heavyHold = 0;
    function tryAttack(dt){
      if(attackCd>0 || player.st<=0) return;
      const isHeavy = heavyHold>0.22;
      const range = isHeavy? 2.2 : 1.6;
      const dmg = isHeavy? 38 : 18;
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
      // Capsule-like forward check: we raycast ahead and check enemy distance
      for(const e of enemies){
        if(e.dead) continue;
        const to = e.mesh.position.clone().sub(camera.position);
        const ahead = dir.dot(to.normalize());
        const dist = e.mesh.position.distanceTo(camera.position);
        if(ahead>0.8 && dist<range){
          let actual = dmg;
          if(e.type==='templar' && e.shield>0 && ! (player.parryWindow>0)){ actual *= 0.25; }
          e.hp -= actual;
          e.stagger = 0.4;
          sfx.hit();
          if(e.hp<=0){ e.dead=true; e.mesh.visible=false; }
        }
      }
      // Boss
      if(boss.active && !boss.dead){
        const toB = boss.mesh.position.clone().sub(camera.position);
        const ahead = dir.dot(toB.clone().normalize());
        const dist = boss.mesh.position.distanceTo(camera.position);
        if(ahead>0.8 && dist<2.9){
          boss.hp -= (isHeavy? 28:12);
          sfx.bossHit();
          if(boss.hp<=0){ boss.dead=true; triggerEnding(); }
          else if(boss.phase===1 && boss.hp<boss.maxHp*0.5){
            boss.phase=2;
            showSub("A choir-scream splinters the air. The flesh opens.");
            // Summon adds
            enemies.push(makeEnemy('hound', 50, -3));
            enemies.push(makeEnemy('squire', 54,  3));
          }
        }
      }
      attackCd = isHeavy? 0.6 : 0.28;
      player.st = Math.max(0, player.st - (isHeavy?16:8));
      heavyHold = 0;
    }

    function tryParry(){
      if(player.st<8) return;
      player.parryWindow = 0.15; // 150ms
      sfx.parry();
    }

    // ---------- UI helpers ----------
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function bar(el, cur, max){ el.style.width = clamp(Math.round((cur/max)*100),0,100) + '%'; }
    function showToast(msg, t=2.0){
      hud.toast.textContent = msg;
      hud.toast.style.display = 'block';
      setTimeout(()=>hud.toast.style.display='none', t*1000);
    }
    function showSub(msg, t=2.0){
      hud.subs.textContent = msg; hud.subs.style.display = 'block';
      setTimeout(()=>{ hud.subs.style.display='none'; }, t*1000);
    }

    // ---------- Save/Load ----------
    const SAVE_KEY = "ashes_v1";
    function save(){
      const data = { shrine: player.lastShrine, hp:player.hp, st:player.st, mp:player.mp };
      localStorage.setItem(SAVE_KEY, JSON.stringify(data));
    }
    function load(){
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return;
      try{
        const d = JSON.parse(raw);
        player.lastShrine = d.shrine||0;
        const s = shrines[player.lastShrine]||shrines[0];
        camera.position.set(s.position.x, 1.6, s.position.z+1.5);
        Object.assign(player, {hp:d.hp||100, st:d.st||100, mp:d.mp||60});
      }catch(e){}
    }

    // ---------- Start / Pause / Title ----------
    function startGame(){
      title.style.display='none';
      initAudio();
      audio.ctx.resume();
      stage.focus();
      stage.click(); // try pointer capture
      load();
      lastTime = performance.now()/1000;
      running = true;
      animate();
      showSub("The bells are silent. Ash chokes the streets.");
    }
    function togglePause(show){
      if(!running) return;
      if(show){ paused = true; pause.style.display = 'flex'; }
      else { paused = false; pause.style.display = 'none'; }
    }
    function quitToTitle(){
      paused=false; running=false;
      pause.style.display='none';
      credits.style.display='none';
      ending.style.display='none';
      title.style.display='grid';
    }

    btn.start.addEventListener('click', startGame);
    btn.how.addEventListener('click', ()=>alert("Controls:\nWASD move, Mouse look, Shift sprint, Space jump/dodge, LMB light/heavy, RMB block/parry, E Eldritch Bolt, Q Grave Lance, R Tincture, Tab wheel, Esc pause/options."));
    btn.resume.addEventListener('click', ()=>togglePause(false));
    btn.reset.addEventListener('click', ()=>{ localStorage.removeItem(SAVE_KEY); showToast("Run reset"); });
    btn.toTitle.addEventListener('click', quitToTitle);

    btn.fs.addEventListener('click', ()=>{
      if(document.fullscreenElement){ document.exitFullscreen(); }
      else { stage.requestFullscreen().catch(()=>{}); }
    });

    opt.fov.addEventListener('input', ()=>{
      camera.fov = parseFloat(opt.fov.value); camera.updateProjectionMatrix();
    });

    // ---------- Movement ----------
    let lastTime = 0, running=false, paused=false;
    const UP = new THREE.Vector3(0,1,0);
    const walkSpeed = 4.3, sprintSpeed = 7.3, airControl = 0.35;
    const grav = 16, jumpV = 5.8;
    let stepAccum = 0;

    function movePlayer(dt){
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, UP).negate();

      let wish = new THREE.Vector3();
      if(keys["KeyW"]) wish.add(forward);
      if(keys["KeyS"]) wish.add(forward.clone().negate());
      if(keys["KeyA"]) wish.add(right.clone().negate());
      if(keys["KeyD"]) wish.add(right);
      if(wish.lengthSq()>0) wish.normalize();

      const sprinting = keys["ShiftLeft"] && player.st>5;
      const maxSpd = sprinting? sprintSpeed : walkSpeed;
      const accel = player.onGround? 28 : 10;
      const control = player.onGround? 1.0 : airControl;

      // Quake-ish accel
      const currentSpd = player.vel.dot(wish);
      let add = maxSpd - currentSpd;
      if(add>0){
        const accelAmt = Math.min(accel*dt*maxSpd, add) * control;
        player.vel.addScaledVector(wish, accelAmt);
      }
      // Gravity
      player.vel.y -= grav*dt;
      // Jump / Dodge (Space)
      if(keys["Space"]){
        if(player.onGround){ player.vel.y = jumpV; player.onGround=false; player.iFrames = 0.25; player.st=Math.max(0, player.st-12); keys["Space"]=false; }
      }

      // Integrate
      camera.position.addScaledVector(player.vel, dt);

      // Ground collide (flat floor y=0)
      if(camera.position.y <= 1.6){
        camera.position.y = 1.6; player.vel.y = 0; if(!player.onGround){ stepAccum=0; } player.onGround=true;
      } else player.onGround=false;

      // Friction
      if(player.onGround){
        player.vel.x *= 0.85; player.vel.z *= 0.85;
        // Footstep sfx
        const horizontalSpeed = Math.hypot(player.vel.x, player.vel.z);
        stepAccum += horizontalSpeed*dt;
        if(stepAccum>2.2){ sfx.step(); stepAccum=0; }
      } else {
        player.vel.x *= 0.995; player.vel.z *= 0.995;
      }

      // Stamina & mana regen
      if(!sprinting) player.st = Math.min(player.maxSt, player.st + (player.onGround? 18:10)*dt);
      player.mp = Math.min(player.maxMp, player.mp + 8*dt);

      // Bounds clamp (soft)
      camera.position.x = clamp(camera.position.x, -30, 64);
      camera.position.z = clamp(camera.position.z, -18, 18);

      // Update bars
      bar(hud.hp, player.hp, player.maxHp);
      bar(hud.st, player.st, player.maxSt);
      bar(hud.mp, player.mp, player.maxMp);
    }

    // ---------- Inputs for combat ----------
    window.addEventListener('mousedown', (e)=>{
      if(paused || !running) return;
      if(e.button===0){
        // Start heavy charge
        heavyHold = 0.0001;
      } else if(e.button===2){
        blockHeld = true;
        tryParry();
      }
    });
    window.addEventListener('mouseup', (e)=>{
      if(paused || !running) return;
      if(e.button===0){
        tryAttack(0);
      } else if(e.button===2){
        blockHeld = false;
      }
    });

    // Spells & items
    window.addEventListener('keydown', (e)=>{
      if(paused || !running) return;
      if(e.code==='KeyE'){ // Eldritch Bolt
        if(player.mp>=8){
          const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
          const from = camera.position.clone().addScaledVector(dir, 0.7).add(new THREE.Vector3(0,-0.2,0));
          shoot(from, dir, 18, 16, 'player'); player.mp -= 8; sfx.cast();
        } else { showToast("Out of mana"); }
      }
      if(e.code==='KeyQ'){ // Grave Lance (burst)
        if(player.mp>=16){
          const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
          for(let i=0;i<3;i++){
            const d = dir.clone();
            d.x += (Math.random()-0.5)*0.06; d.y += (Math.random()-0.5)*0.06; d.z += (Math.random()-0.5)*0.06; d.normalize();
            const from = camera.position.clone().addScaledVector(d, 0.7).add(new THREE.Vector3(0,-0.2,0));
            shoot(from, d, 22, 12, 'player');
          }
          player.mp -= 16; sfx.cast();
        } else { showToast("Out of mana"); }
      }
      if(e.code==='KeyR'){ // Tincture
        if(player.hp<player.maxHp){ player.hp = Math.min(player.maxHp, player.hp+35); showToast("Tincture consumed"); }
      }
      if(e.code==='Tab'){ e.preventDefault(); showToast("Wheel: (placeholder) — swaps spells/consumables"); }
    }, false);

    // ---------- Enemy AI ----------
    function updateEnemies(dt){
      const ppos = camera.position;
      for(const e of enemies){
        if(e.dead) continue;
        const pos = e.mesh.position;
        const toP = new THREE.Vector3().subVectors(ppos, pos);
        const dist = toP.length();
        e.aggro = dist < 12;
        if(e.stagger>0){ e.stagger -= dt; continue; }

        if(e.type==='archer'){
          e.cd -= dt;
          if(dist>6){ pos.addScaledVector(toP.setLength(e.speed*0.4*dt), 1); }
          else if(dist<4){ pos.addScaledVector(toP.setLength(-e.speed*0.6*dt), 1); }
          if(e.cd<=0 && dist<16){
            const dir = new THREE.Vector3().subVectors(ppos, pos).setLength(14);
            shoot(pos.clone().add(new THREE.Vector3(0,0.6,0)), dir, 1, 10, 'enemy');
            e.cd = 2.2;
          }
        } else if(e.type==='wraith'){
          e.teleportCd -= dt;
          if(e.teleportCd<=0 && dist>6){
            // flicker teleport closer
            const dir = toP.clone().setLength(Math.max(2, dist-3));
            pos.add(dir);
            e.teleportCd = 2.8;
          } else {
            pos.addScaledVector(toP.setLength(e.speed*0.4*dt), 1);
          }
        } else {
          // melee types advance
          pos.addScaledVector(toP.setLength(e.speed*dt), 1);
          e.cd -= dt;
          if(e.cd<=0 && dist<1.6){
            // melee attack
            if(player.iFrames<=0){
              player.hp -= (e.type==='templar'? 18 : 10);
              if(player.hp<=0){ onPlayerDeath(); }
            }
            // parry check window grant riposte
            if(player.parryWindow>0){
              e.stagger = 1.2; e.hp -= 28; sfx.riposte();
              if(e.hp<=0){ e.dead=true; e.mesh.visible=false; }
            }
            e.cd = 1.2;
          }
        }
        e.mesh.position.copy(pos);
      }
    }

    // ---------- Boss AI ----------
    function updateBoss(dt){
      if(boss.dead) return;
      const p = camera.position, b = boss.mesh.position;
      const dist = p.distanceTo(b);
      if(dist<14) boss.active = true;
      if(!boss.active) return;
      boss.cd -= dt;
      // idling sway
      boss.mesh.position.y = 3 + Math.sin(perfNow*2.0)*0.2;
      if(boss.cd<=0){
        if(boss.phase===1){
          // Slam or bile
          if(Math.random()<0.6){
            // slam: short-range shock
            if(dist<3.6 && player.iFrames<=0){ player.hp -= 22; }
            showSub("The Congregation slams the stones.");
            boss.cd = 2.8;
          } else {
            // orbs
            for(let i=0;i<3;i++){
              const dir = new THREE.Vector3().subVectors(p, b).normalize();
              dir.x += (Math.random()-0.5)*0.2; dir.y += (Math.random()-0.5)*0.1; dir.z += (Math.random()-0.5)*0.2; dir.normalize();
              shoot(b.clone().add(new THREE.Vector3(0,1.5,0)), dir, 10, 14, 'enemy');
            }
            boss.cd = 3.2;
          }
        } else {
          // Phase 2: crawling torsos (adds) + triple slam window
          if(Math.random()<0.5){
            enemies.push(makeEnemy('hound', b.x+(Math.random()*2-1)*3, b.z+(Math.random()*2-1)*3));
            showSub("Crawling forms spill from the choir pit.");
            boss.cd = 2.5;
          } else {
            // triple slam cue: create riposte window if survived
            if(dist<4.2 && player.iFrames<=0){ player.hp -= 26; }
            setTimeout(()=>{ if(dist<4.2 && player.iFrames<=0){ player.hp -= 26; } }, 300);
            setTimeout(()=>{ if(dist<4.2 && player.iFrames<=0){ player.hp -= 26; } showSub("Weakpoint exposed!"); }, 600);
            boss.cd = 4.0;
          }
        }
      }
      if(player.hp<=0) onPlayerDeath();
    }

    // ---------- Projectiles update & collisions ----------
    function updateProjectiles(dt){
      for(let i=projectiles.length-1;i>=0;i--){
        const p = projectiles[i];
        p.mesh.position.addScaledVector(p.vel, dt);
        p.ttl -= dt;
        let hit = false;
        if(p.owner==='player'){
          for(const e of enemies){
            if(e.dead) continue;
            if(e.mesh.position.distanceTo(p.mesh.position)<0.9){
              e.hp -= p.dmg; e.stagger = 0.2; hit=true; sfx.hit();
              if(e.hp<=0){ e.dead=true; e.mesh.visible=false; }
              break;
            }
          }
          if(boss.active && !boss.dead && boss.mesh.position.distanceTo(p.mesh.position)<2.6){
            boss.hp -= p.dmg*0.6; hit=true; sfx.bossHit();
            if(boss.hp<=0){ boss.dead=true; triggerEnding(); }
          }
        } else {
          if(camera.position.distanceTo(p.mesh.position)<1.0 && player.iFrames<=0){
            player.hp -= p.dmg*0.7; hit=true;
            if(player.hp<=0) onPlayerDeath();
          }
        }
        if(hit || p.ttl<=0){
          world.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose();
          projectiles.splice(i,1);
        }
      }
    }

    function onPlayerDeath(){
      player.hp = player.maxHp; player.st = player.maxSt; player.mp = player.maxMp;
      const s = shrines[player.lastShrine]||shrines[0];
      camera.position.set(s.position.x, 1.6, s.position.z+1.2);
      showToast("You fall into ash. Shrine rekindled.");
      save();
    }

    // Shrine interaction (auto-activate when near)
    function updateShrines(){
      for(let i=0;i<shrines.length;i++){
        const s = shrines[i];
        if(camera.position.distanceTo(s.position)<1.6){
          if(player.lastShrine!==i){
            player.lastShrine = i; sfx.shrine(); showToast("Shrine kindled (checkpoint).");
            save();
          }
        }
      }
    }

    // ---------- Ending / Credits ----------
    function triggerEnding(){
      running=false; ending.style.display='flex';
      window.addEventListener('keydown', rollCreditsOnce, { once:true });
    }
    function rollCreditsOnce(){
      ending.style.display='none'; credits.style.display='flex';
      window.addEventListener('keydown', ()=>{ credits.style.display='none'; quitToTitle(); }, { once:true });
    }

    // ---------- Resize ----------
    function onResize(){
      WIDTH = stage.clientWidth; HEIGHT = stage.clientHeight;
      renderer.setSize(WIDTH, HEIGHT, false);
      camera.aspect = WIDTH/HEIGHT; camera.updateProjectionMatrix();
    }
    new ResizeObserver(onResize).observe(stage);

    // ---------- Main Loop ----------
    let perfNow = 0;
    function animate(){
      if(!running) return;
      const now = performance.now()/1000;
      const dt = Math.min(0.033, now - lastTime); // clamp
      lastTime = now; perfNow = now;

      if(paused){ requestAnimationFrame(animate); return; }

      // timers
      attackCd = Math.max(0, attackCd - dt);
      player.parryWindow = Math.max(0, player.parryWindow - dt);
      player.iFrames = Math.max(0, player.iFrames - dt);
      if(heavyHold>0) heavyHold += dt;

      movePlayer(dt);
      updateShrines();
      updateEnemies(dt);
      updateBoss(dt);
      updateProjectiles(dt);
      updateFireLight(now);
      postFx();

      // Light wobble (PSX-ish minor jitter)
      camera.matrixWorldNeedsUpdate = true;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // ---------- Interaction helpers ----------
    // Activate first shrine as spawn after ~1s
    setTimeout(()=>{ player.lastShrine = 0; save(); }, 1000);

    // Pointer lock UX
    stage.addEventListener('click', ()=>{
      if(audio.ready) audio.ctx.resume().catch(()=>{});
    }, { once:false });

    // Simple lore pickup near market
    const loreSpot = new THREE.Vector3(2,1.6,-1);
    let loreShown=false;
    setInterval(()=>{
      if(running && !loreShown && camera.position.distanceTo(loreSpot)<1.2){
        showToast("Lore scrap: 'The bells fell silent the night the king wept.'");
        loreShown=true;
      }
    }, 500);

  </script>
</body>
</html>
